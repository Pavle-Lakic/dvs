-- acc_hist.vhd

-- This file was auto-generated as a prototype implementation of a module
-- created in component editor.  It ties off all outputs to ground and
-- ignores all inputs.  It needs to be edited to make it do something
-- useful.
-- 
-- This file will not be automatically regenerated.  You should check it in
-- to your version control system if you want to keep it.

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity acc_hist is
	port (
		clk                     : in  std_logic                     := '0';             --       clock.clk
		reset                   : in  std_logic                     := '0';             --       reset.reset
		avs_control_address     : in  std_logic                     := '0';             --		 avs_control.address
		avs_control_read        : in  std_logic                     := '0';             --            .read
		avs_control_readdata    : out std_logic_vector(31 downto 0);                    --            .readdata
		avs_control_write       : in  std_logic                     := '0';             --            .write
		avs_control_writedata   : in  std_logic_vector(31 downto 0) := (others => '0'); --            .writedata
		avs_control_waitrequest : out std_logic;                                        --            .waitrequest
		asi_in_data             : in  std_logic_vector(7 downto 0)  := (others => '0'); --       asi_in.data
		asi_in_ready            : out std_logic;                                        --            .ready
		asi_in_valid            : in  std_logic                     := '0';             --            .valid
		asi_in_eop              : in  std_logic                     := '0';             --            .endofpacket
		asi_in_sop              : in  std_logic                     := '0';             --            .startofpacket
		aso_out_data            : out std_logic_vector(15 downto 0);                    --		 aso_out.data
		aso_out_ready           : in  std_logic                     := '0';             --            .ready
		aso_out_valid           : out std_logic;                                        --            .valid
		aso_out_eop             : out std_logic;                                        --            .endofpacket
		aso_out_sop             : out std_logic;                                        --            .startofpacket
		aso_out_empty           : out std_logic                                         --            .empty
	);
end entity acc_hist;

architecture rtl of acc_hist is

component ram_controler is 
	port
	(
		address		: in std_logic_vector (7 DOWNTO 0);
		clk			: in std_logic;
		data			: in std_logic_vector (15 DOWNTO 0);
		wren			: in std_logic;
		addr_ready	: in std_logic;
		reset			: in std_logic;
		clear			: in std_logic;
		inc			: in std_logic;
		in_ready		: out std_logic;
		out_valid	: out std_logic;
		q				: out std_logic_vector (15 DOWNTO 0)	
	);
end component;

component diff is
	port
	(
		-- Input ports
		
		input	: in  std_logic;
		clk	: in std_logic;
		reset : in std_logic;
		-- Output ports
		
		output	: out std_logic
		
	);
end component;

--	CONTROL_REG
-- Sa njim moze da se vrsi i upis i citanje.
--	 ____________________________________________
--	| c_run | c_res | c_clear | reserved | c_nop |
--	|   31  |   30  |   29    |  28..19  | 18..0 |

	signal control_reg : std_logic_vector(31 downto 0);
	
--	STATUS_REG
-- Iz statusnog registra moze samo da se cita.
--	 ______________________________________________
--	| status_reg_state | reserved | s_nopp | s_cnt |
--	|      31..29      |    28    | 27..9  | 8..0  |

	signal status_reg : std_logic_vector (31 downto 0);
	
	-- oznacava da je statusni registar adresiran, i da je avs_control_write bit aktivan
	signal control_strobe : std_logic;
	
	-- adresa kontrolnog registra
	constant CONTROL_ADDR : std_logic := '1';
	
	-- adresa statusnog registra
	constant STATUS_ADDR  : std_logic := '0';

	-- pomocni signal koji omogucava citanje iz registra, za avs_control_waitrequest
	signal control_waitrq : std_logic;

	type state is (idle, 		-- cekanje softverskog starta, pre starta treba resetovati RAM							"000"
				  wait_input,		-- nakon starta, cekanje da RAM bude spreman da primi podatak, i ulaz validan		"001"
				  process_state, 	-- medjustanje 																		"010"
				  wait_output,		-- cekanje da izlazni DMA bude spreman da procita podatak							"011"
				  output_read,		-- upis u izlazni DMA																"100"
				  done); 			-- stanje da je sve zavrseno, iz njega moze nazad samo soft ili hard resetom		"101"

	signal current_state, next_state : state;

	-- ulazni piksel, iz ulaznog DMA, ponasa se kao adresa u RAM-u u ovom modulu
	signal input_sample : std_logic_vector(7 downto 0);
	
	-- izlazni podatak, u izlazni DMA
	signal output_sample : std_logic_vector(15 downto 0);
	
	-- za sada se ne koristi, moze kasnije kao specificni ulazni podatak u RAM
	signal data_ram	: std_logic_vector(15 downto 0);
	
	-- signal dozvole za upis u RAM, za sada se ne koristi
	signal wren_ram : std_logic;
	
	-- signal da je spreman podatak na nekoj adresi da se procita iz RAM, za stanje output_read sluzi
	signal adrr_ready_ram : std_logic;
	
	-- postavlja se na aktivno stanje kada je ili softverski ili hardverski reset aktivan
	signal reset_global : std_logic;
	
	-- signal za postavljanje svih podataka u RAM-u na 0
	signal c_clear : std_logic;
	
	-- signal koji sluzi da se na postavljenoj adresi podatak poveca za 1
	signal inc_ram : std_logic;
	
	-- oznacava da je RAM spreman da primi nov podatak
	signal in_ready_ram : std_logic;
	
	-- oznacava da je na izlaznom baferu u ramu validan podatak
	signal out_valid_ram : std_logic;
	
	-- izlazni podatak iz RAM-a
	signal q_ram : std_logic_vector (15 downto 0);
	
	-- signal koji oznacava broj piksela koji treba da se obradi
	signal c_nop : unsigned (18 downto 0);	
	
	-- softverski znak da modul treba da zapocne rad
	signal c_run : std_logic;
	
	-- softverski reset
	signal c_res : std_logic;
	
	-- diferenciran c_run
	signal c_run_diff : std_logic;
	
	-- diferenciran c_clear
	signal c_clear_diff : std_logic;
	
	-- prva 3 bita statusnog registra, oznacavaju stanje
	signal status_reg_state : std_logic_vector (2 downto 0);
	
	-- oznacava broj obradjenih piksela
	signal s_nopp : natural range 0 to 262144;
	
	-- oznacava do koje je adrese izlazni DMA stigao sa citanjem iz RAM-a
	signal s_cnt  : natural range 0 to 256;
	
begin
RAM: ram_controler port map(
		address => input_sample,
		clk => clk,
		data => data_ram,
		wren => wren_ram,
		addr_ready => adrr_ready_ram,
		reset => reset_global,
		clear => c_clear_diff,
		inc => inc_ram,
		in_ready => in_ready_ram,
		out_valid => out_valid_ram,
		q => q_ram
);

-- diferencira c_run da ne bi run-ovao non stop, doduse reseno sa stanjem done
DIFF_C_RUN: diff port map(
		input => c_run,
		clk => clk,
		reset => reset_global,
		output => c_run_diff
);

-- diferencira c_clear da ne bi non stop clear-ovao RAM, vec da mora to da se uradi ponovnim upisom
DIFF_C_CLEAR: diff port map(
		input => control_reg(29),
		clk => clk,
		reset => reset_global,
		output => c_clear_diff
);

	-- za upis u kontrolni registar
	control_strobe <= '1' when (avs_control_write = '1') and (avs_control_address = CONTROL_ADDR) else '0';
	
	-- softverski i hardverski reset zajedno
	reset_global <= c_res or reset;
	
	--za izlazni DMA
	aso_out_data <= output_sample;
	
	-- proces za upis u kontrolni registar
	write_control_reg : process(clk, control_strobe, avs_control_write) is 
	begin
		if (reset = '1') then
			control_reg <= (others => '0');
		elsif(rising_edge(clk)) then
			if (avs_control_write = '1') then
				control_reg(31 downto 0) <= avs_control_writedata;
			end if;
		end if;
	end process;
	
	-- uzimanje znacajnih vrednosti iz kontrolnog registra
	c_bits_write : process(clk) is 
	begin
		if (reset = '1') then
			c_res <= '0';
			c_clear <= '0';
			c_nop <= (others => '0');
		elsif (rising_edge(clk)) then
			c_run <= control_reg(31);
			c_res <= control_reg(30);
			c_clear <= control_reg(29);
			c_nop <= unsigned(control_reg(18 downto 0));
		end if;
	end process;

	-- citanje iz controlnog i statusnog registra, ako kontrolni nije adresiran, uvek je statusni
	read_mmaped_reg : process(clk, avs_control_address,avs_control_read) is
	begin
		if (reset = '1') then
			avs_control_readdata <= x"00000000";
			control_waitrq <= '1';			
		elsif(rising_edge(clk)) then
			control_waitrq <= '0';
			if (avs_control_read = '1') then
				control_waitrq <= '0';
				if (avs_control_address = CONTROL_ADDR) then
					avs_control_readdata <= control_reg;
				else
					avs_control_readdata <= status_reg;
				end if;
			end if;
		end if;	
	end process;

	-- da bi moglo da se cita iz registra
	avs_control_waitrequest <= avs_control_read and control_waitrq;
	
	-- proces za ispis izlaza RAM-a u output sample, a samim tim i u aso_out_data
	process_sample : process(clk, current_state, aso_out_ready)
	begin
		if (reset = '1') then
			output_sample <= x"BEEF";
		elsif (rising_edge(clk)) then
			if ((current_state = output_read) and aso_out_ready = '1') then
				output_sample (15 downto 0) <= q_ram;
			end if;
		end if;
	end process;
	
	-- citanje podatka iz asi_in_data kada je RAM spreman da primi nove podatke i kada je ulaz validan
	read_sample : process(clk, s_cnt, current_state)
	begin
		if (reset = '1') then
			input_sample <= x"00";
		elsif (rising_edge(clk)) then
			if (current_state = wait_output) then
				input_sample <= std_logic_vector(to_unsigned(s_cnt, 8));
			elsif (in_ready_ram = '1' and asi_in_valid = '1') then
				input_sample <= asi_in_data;
			end if;
		end if;
	end process;
	
	-- ideja je Moore-ova masina stanja da se napravi
	control_fsm: process(clk)
	begin
		if (reset = '1') then
			current_state <= idle;
		elsif (rising_edge(clk)) then
			current_state <= next_state;
		end if;
	end process;	
	
	-- logika masine stanja
	streaming_protocol: process(current_state, asi_in_valid, aso_out_ready, c_run_diff, s_cnt, s_nopp, in_ready_ram, c_run) -- mozda ce da fali jos nesto kasnije u senz listi
	begin
		case current_state is
			when idle =>		
				if (c_run_diff = '1' and in_ready_ram = '1') then	
					next_state <= wait_input;
				else
					next_state <= idle;
				end if;

			when wait_input =>
				if (s_nopp = c_nop) then
					next_state <= wait_output;
				elsif (asi_in_valid = '1' and in_ready_ram = '1') then
					next_state <= process_state;
				else
					next_state <= wait_input;
				end if;
				
			when process_state =>
				next_state <= wait_input;
								
			when wait_output =>
				if (s_cnt = 255) then
					next_state <= done;
				elsif (aso_out_ready = '1' and in_ready_ram = '1') then
					next_state <= output_read;
				end if;
				
			when output_read =>
				next_state <= wait_output;
				
			when done =>
				next_state <= done;
				
		end case;
	end process;	
	
	-- proces koji na osnovu stanja i countera update-uje statusni registar
	status_reg_control: process(clk) is
	begin
		if (reset = '1') then
			status_reg <= (others => '0');
		elsif (rising_edge(clk)) then
			status_reg(31 downto 29) <= status_reg_state;
			status_reg(27 downto 9) <= std_logic_vector(to_unsigned(s_nopp, 19));
			status_reg(8 downto 0) <= std_logic_vector(to_unsigned(s_cnt, 9));		
		end if;
	end process;
	
	-- proces koji broji counter-e, sinhroni mora da bude
	counter_process: process(clk, reset, status_reg_state, c_res) is
	begin
		if (reset = '1') then
			s_nopp <= 0;
			s_cnt <= 0;
		elsif (rising_edge(clk)) then
			if (status_reg_state = "000") then
				s_nopp <= 0;
				s_cnt <= 0;
			elsif (status_reg_state = "010") then
				s_nopp <= s_nopp + 1;
			elsif(status_reg_state = "100") then
				s_cnt <= s_cnt + 1;		
			end if;
		end if;
	end process;
	
	-- na osnovu stanja postavlja izlaze
	output_process: process(current_state) is
	begin
		case(current_state) is			
			when idle =>
				status_reg_state <= "000";
				aso_out_valid <= '0';
				asi_in_ready <= '0';
				adrr_ready_ram <= '0';
				inc_ram <= '0';
				
			when wait_input =>
				status_reg_state <= "001";
				aso_out_valid <= '0';
				asi_in_ready <= in_ready_ram;
				adrr_ready_ram <= '0';
				inc_ram <= '0';
			
			when process_state =>	
				status_reg_state <= "010";
				aso_out_valid <= '0';
				asi_in_ready <= in_ready_ram;
				adrr_ready_ram <= '0';
				inc_ram <= '1';
	
			when wait_output =>				
				status_reg_state <= "011";
				aso_out_valid <= out_valid_ram;
				asi_in_ready <= '0';
				adrr_ready_ram <= '0';
				inc_ram <= '0';
				
			when output_read =>	
				status_reg_state <= "100";
				aso_out_valid <= out_valid_ram;
				asi_in_ready <= '0';
				adrr_ready_ram <= '1';
				inc_ram <= '0';
			
			when done =>
				status_reg_state <= "101";
				aso_out_valid <= '0';
				asi_in_ready <= '0';
				adrr_ready_ram <= '0';
				inc_ram <= '0';
				
		end case;
	end process;
	
	aso_out_eop <= '0';
	aso_out_sop <= '0';
	aso_out_empty<= '0';

end architecture rtl; -- of acc_hist

